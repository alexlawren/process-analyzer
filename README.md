# Анализатор процессов (Process Analyzer)

Консольное Java-приложение для анализа системных процессов, разработанное в рамках лабораторной работы по курсу "Инструменты поддержки промышленной разработки программного обеспечения" (ИППРПО).

Приложение является кроссплатформенным: оно читает список активных процессов с помощью системных команд (`tasklist` для Windows, `ps aux` для Linux), анализирует их и выводит в консоль отчет в соответствии с заданными правилами.

![CI Build and Test](https://github.com/alexlawren/process-analyzer/actions/workflows/build.yml/badge.svg)

## Технологический стек

*   **Java**: Язык программирования. Проект написан с использованием JDK 17.
*   **Gradle**: Система автоматической сборки проекта.
*   **JUnit 5**: Фреймворк для модульного тестирования.
*   **Checkstyle**: Инструмент для статического анализа кода по правилам Google Style.
*   **GitHub Actions**: Система для автоматизации CI/CD (сборка, тестирование, анализ, релизы).

## Требования для запуска

*   **Git**: Для клонирования репозитория.
*   **Java Development Kit (JDK)**: **Версия 17 или выше**.
    *   Проект использует JDK 17. Если у вас установлена другая версия (например, 18 или 21), приложение должно работать без изменений. Если у вас более старая версия, потребуется изменить конфигурацию сборки.

## Установка и настройка

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/alexlawren/process-analyzer.git
    cd process-analyzer
    ```

2.  **Создайте файл конфигурации:**

    > **Важно!** Файл `app.properties` не отслеживается системой контроля версий (добавлен в `.gitignore`) и должен быть создан вручную в **корневой папке проекта**.

    Создайте файл `app.properties` и скопируйте в него следующее содержимое:
    ```properties
    # Режим сортировки: CPU или MEMORY
    # Определяет, по какому параметру сортировать процессы в отчете.
    # - CPU: по убыванию использования CPU (результат виден в основном на Linux).
    # - MEMORY: по убыванию использования оперативной памяти.
    sort.by=MEMORY

    # Пороги для фильтрации процессов.
    # Будут показаны процессы, которые превышают ХОТЯ БЫ ОДИН из порогов.
    threshold.cpu.percent=10
    threshold.memory.mb=1000

    # Имя процесса для поиска.
    # Будет найден первый процесс, имя которого содержит эту подстроку (без учета регистра).
    search.process.name=java
    ```
    Вы можете изменять эти параметры для решения своих задач.

## Сборка и запуск

Проект использует плагин `application` и Gradle Wrapper, что делает его запуск очень простым. Вам не нужно устанавливать Gradle глобально.

1.  **Сборка, тестирование и анализ (рекомендуется):**

    Эта команда скомпилирует исходный код, запустит все тесты и выполнит проверку стиля кода с помощью Checkstyle.

    *   Для Linux / macOS:
        ```bash
        ./gradlew build
        ```
    *   Для Windows:
        ```bash
        gradlew build
        ```

2.  **Простой запуск приложения:**

    Эта команда запустит приложение напрямую, используя конфигурацию из `app.properties`.

    *   Для Linux / macOS:
        ```bash
        ./gradlew run
        ```
    *   Для Windows:
        ```bash
        gradlew run
        ```

### Пример вывода в консоль
Task :app:run
Получение списка системных процессов...
Найдено и обработано процессов: 290
--- Задание 1: Сортировка (согласно sort.by=MEMORY) ---
Топ 5 процессов:
PID: 19460, CPU: 0.0%, MEM: 2050MB, Name: idea64.exe
PID: 21076, CPU: 0.0%, MEM: 1196MB, Name: msedge.exe
...
--- Задание 2: Поиск PID (для search.process.name=java) ---
Найден процесс с PID: 18620
--- Задание 3: Фильтрация по порогам ---
Поиск процессов, потребляющих >10% CPU или >1000MB RAM:
PID: 21076, CPU: 0.0%, MEM: 1196MB, Name: msedge.exe
PID: 19460, CPU: 0.0%, MEM: 2050MB, Name: idea64.exe
BUILD SUCCESSFUL in 1s
code
Code
## CI/CD Pipeline

Проект использует два workflow в GitHub Actions для полной автоматизации.

### 1. Сборка и проверка (`build.yml`)
Этот workflow запускается при каждом `push` в `main` и при создании Pull Request. Он выполняет:
*   **Статический анализ:** Запуск `checkstyleMain` для проверки стиля кода.
*   **Матричная сборка:** Проект параллельно собирается и тестируется на `ubuntu-latest` и `windows-latest` для гарантии кроссплатформенности.

### 2. Создание релиза (`release.yml`)
Этот workflow запускается только при отправке в репозиторий тега формата `v*.*.*` (например, `v1.0.1`). Он автоматически:
1.  Собирает проект.
2.  Создает новый релиз на GitHub с именем тега.
3.  Прикрепляет к релизу собранный `.jar`-файл.

## Автор

*   **alexlawren**